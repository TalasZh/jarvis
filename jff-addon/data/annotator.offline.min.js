/*  Offline Annotator Plugin - v1.0.0
 *  Copyright 2012, Compendio <www.compendio.ch>
 *  Released under the MIT license
 *  More Information: http://github.com/aron/annotator.offline.js
 */
((function () {
    var Offline, Store, __bind = function (fn, me) {
            return function () {
                return fn.apply(me, arguments)
            }
        },
        __hasProp = Object.prototype.hasOwnProperty,
        __extends = function (child, parent) {
            function ctor() {
                this.constructor = child
            }

            ctor.prototype = parent.prototype;
            child.prototype = new ctor;
            child.__super__ = parent.prototype;

            for (var key in parent) {
                if (__hasProp.call(parent, key)) {
                    (child[key] = parent[key]);
                }
            }
            return child;
        };
    Annotator.Plugin.Offline = Offline = function (a) {
        function Offline() {
            this._onOffline = __bind(this._onOffline, this),
                this._onOnline = __bind(this._onOnline, this);
            var event, handler, handlers;
            Offline.__super__.constructor.apply(this, arguments);
            this.store = new Offline.Store;
            this.cache = {};
            handlers = {
                online: "online",
                offline: "offline",
                beforeAnnotationLoaded: "setAnnotationData",
                beforeAnnotationCreated: "setAnnotationDataBeforeCreation",
                annotationCreatedCallback: "getCreatedAnnotation"
            };

            for (event in handlers) {
                if (!__hasProp.call(handlers, event)) continue;
                handler = handlers[event];
                if (typeof this.options[handler] === "function") {
                    this.on(event, jQuery.proxy(this.options, handler));
                }
            }
        }

        var jQuery, _t;
        __extends(Offline, a);
        _t = Annotator._t;
        jQuery = Annotator.$;
        Offline.ANNOTATION_PREFIX = "annotation.";
        Offline.uuid = function () {
            return ("" + Math.random() + (new Date).getTime()).slice(2)
        };
        Offline.prototype.events = {
            annotationCreated: "_onAnnotationCreated",
            annotationUpdated: "_onAnnotationUpdated",
            annotationDeleted: "_onAnnotationDeleted"
        };
        Offline.prototype.options = {
            getUniqueKey: function (annotation) {
                if (!annotation.id) {
                    annotation.id = Offline.uuid();
                }
                return annotation.id;
            },
            shouldLoadAnnotation: function (a) {
                return !0
            }
        };
        Offline.prototype.pluginInit = function () {

            if (!Annotator.supported()) {
                return;
            }
            this.loadAnnotationsFromStore();
            if (this.isOnline()) {
                this.online();
            } else {
                this.offline();
            }

            return jQuery(window).bind({
                online: this._onOnline,
                offline: this._onOffline
            });
        };
        Offline.prototype.annotations = function () {
            return this.cache
        };
        Offline.prototype.online = function () {
            return this.publish("online", [this]), this
        };
        Offline.prototype.offline = function () {
            return this.publish("offline", [this]), this
        };
        Offline.prototype.isOnline = function () {
            return window.navigator.onLine
        };
        Offline.prototype.loadAnnotationsFromStore = function () {
            var annotation, annotations, current, _i, _len;
            current = [];
            annotations = this.store.all(Offline.ANNOTATION_PREFIX);
            for (_i = 0, _len = annotations.length; _i < _len; _i++) {
                annotation = annotations[_i];
                if (this.options.shouldLoadAnnotation(annotation)) {
                    this.publish("beforeAnnotationLoaded", [annotation, this]);
                    this.publish("annotationLoaded", [annotation, this]);
                    this.cache[this.keyForAnnotation(annotation)] = annotation;
                    current.push(annotation);
                }
            }
            if (current.length) {
                this.annotator.loadAnnotations(current);
            }
            return this;
        };
        Offline.prototype.addAnnotation = function (annotation, options) {

            var isLoaded;
            if (options == null) {
                options = {};
            }
            isLoaded = this.cache[this.options.getUniqueKey(annotation)];
            if (!isLoaded && this.options.shouldLoadAnnotation(annotation)) {
                this.annotator.setupAnnotation(annotation, options.silent);
            } else {
                this.updateStoredAnnotation(annotation);
            }
            return this;
        };
        Offline.prototype.removeAnnotation = function (annotation) {

            if (this.options.shouldLoadAnnotation(annotation)) {
                this.annotator.deleteAnnotation(annotation);
            } else {
                this.removeStoredAnnotation(annotation);
            }
            return this;
        };
        Offline.prototype.updateStoredAnnotation = function (annotation) {
            console.log("annotation updated");
            var id, key, local, storable;
            id = this.keyForAnnotation(annotation);
            key = this.keyForStore(annotation);
            local = this.cache[id];
            if (local) {
                jQuery.extend(local, annotation);
            } else {
                local = this.cache[id] = annotation;
            }
            storable = jQuery.extend({}, local);
            delete storable.highlights;
            this.store.set(key, storable);
            return this;
        };
        Offline.prototype.removeStoredAnnotation = function (annotation) {

            var id, key;
            id = this.keyForAnnotation(annotation);
            key = this.keyForStore(annotation);
            this.store.remove(key);
            delete this.cache[id];
            return this;
        };
        Offline.prototype.keyForAnnotation = function (annotation) {
            return this.options.getUniqueKey.call(this, annotation, this);
        };
        Offline.prototype.keyForStore = function (annotation) {
            return Offline.ANNOTATION_PREFIX + this.keyForAnnotation(annotation);
        };
        Offline.prototype._onOnline = function (event) {
            return this.online();
        };
        Offline.prototype._onOffline = function (event) {
            return this.offline()
        };
        Offline.prototype.annotationCreatedCallback = function (annotation) {
            this.publish("annotationCreatedCallback", [annotation]);
            return annotation;
        };
        Offline.prototype._onAnnotationCreated = function (annotation) {
            var result = this.updateStoredAnnotation(annotation);
            this.annotationCreatedCallback(annotation);
            return result;
        };
        Offline.prototype._onAnnotationUpdated = function (annotation) {
            return this.updateStoredAnnotation(annotation);
        };
        Offline.prototype._onAnnotationDeleted = function (annotation) {
            return this.removeStoredAnnotation(annotation);
        };
        return Offline
    }(Annotator.Plugin);
    Annotator.Plugin.Offline.Store = Store = function (a) {
        function Store() {
            Store.__super__.constructor.apply(this, arguments)
        }

        __extends(Store, a);
        Store.KEY_PREFIX = "annotator.offline/";
        Store.CACHE_DELIMITER = "--cache--";
        Store.localStorage = window.localStorage;
        Store.isSupported = function () {
            try {
                return "localStorage"in window && window.localStorage !== null
            } catch (a) {
                return !1
            }
        };
        Store.now = function () {
            return (new Date).getTime()
        };
        Store.prototype.all = function (partial) {
            var key, prefix, value, values;
            if (partial == null) {
                partial = "";
            }
            values = [];
            prefix = this.prefixed(partial);
            for (key in localStorage) {
                if (key.indexOf(prefix) === 0) {
                    value = this.get(key.slice(Store.KEY_PREFIX.length));
                    values.push(value);
                }
            }
            return values;
        };
        Store.prototype.get = function (key) {
            var value;
            value = Store.localStorage.getItem(this.prefixed(key));
            if (value) {
                value = this.checkCache(value);
                if (!value) {
                    this.remove(key);
                }
            }
            return JSON.parse(value);
        };
        Store.prototype.set = function (key, value, time) {
            value = JSON.stringify(value);
            if (time) {
                value = (Store.now() + time) + Store.CACHE_DELIMITER + value;
            }
            try {
                Store.localStorage.setItem(this.prefixed(key), value);
            } catch (error) {
                this.publish('error', [error, this]);
            }
            return this;
        };
        Store.prototype.remove = function (key) {
            Store.localStorage.removeItem(this.prefixed(key));
            return this;
        };
        Store.prototype.clear = function () {

            var key, localStorage;
            localStorage = Store.localStorage;
            for (key in localStorage) {
                if (key.indexOf(Store.KEY_PREFIX) === 0) {
                    localStorage.removeItem(key);
                }
            }
            return this;
        };
        Store.prototype.prefixed = function (key) {
            return Store.KEY_PREFIX + key
        };
        Store.prototype.checkCache = function (value) {
            var cached;
            if (value.indexOf(Store.CACHE_DELIMITER) > -1) {
                cached = value.split(Store.CACHE_DELIMITER);
                value = Store.now() > cached.shift() ? null : cached.join(Store.CACHE_DELIMITER);
            }
            return value;
        };
        return Store;
    }(Annotator.Delegator)
})).call(this);
