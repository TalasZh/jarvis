/*  Offline Annotator Plugin - v1.0.0
 *  Copyright 2012, Compendio <www.compendio.ch>
 *  Released under the MIT license
 *  More Information: http://github.com/aron/annotator.offline.js
 */
((function () {
    var a, b, c = function (a, b) {
        return function () {
            return a.apply(b, arguments)
        }
    }, d = Object.prototype.hasOwnProperty, e = function (a, b) {
        function e() {
            this.constructor = a
        }

        for (var c in b)d.call(b, c) && (a[c] = b[c]);
        return e.prototype = b.prototype, a.prototype = new e, a.__super__ = b.prototype, a
    };
    Annotator.Plugin.Offline = a = function (a) {
        function Offline() {
            this._onOffline = c(this._onOffline, this), this._onOnline = c(this._onOnline, this);
            var a, e, f;
            Offline.__super__.constructor.apply(this, arguments),
                this.store = new Offline.Store,
                this.cache = {},
                f = {
                    online: "online",
                    offline: "offline",
                    beforeAnnotationLoaded: "setAnnotationData",
                    beforeAnnotationCreated: "setAnnotationDataBeforeCreation"
                };
            for (a in f) {
                if (!d.call(f, a))continue;
                e = f[a],
                typeof this.options[e] == "function" && this.on(a, b.proxy(this.options, e))
            }
        }

        var b, f;
        return e(Offline, a),
            f = Annotator._t,
            b = Annotator.$,
            Offline.ANNOTATION_PREFIX = "annotation.",
            Offline.uuid = function () {
                return ("" + Math.random() + (new Date).getTime()).slice(2)
            },
            Offline.prototype.events = {
                annotationCreated: "_onAnnotationCreated",
                annotationUpdated: "_onAnnotationUpdated",
                annotationDeleted: "_onAnnotationDeleted"
            },
            Offline.prototype.options = {
                getUniqueKey: function (a) {
                    return a.id || (a.id = Offline.uuid()), a.id
                },
                shouldLoadAnnotation: function (a) {
                    return !0
                }
            },
            Offline.prototype.pluginInit = function () {

                if (!Annotator.supported()) {
                    return;
                }
                this.loadAnnotationsFromStore();
                if (this.isOnline()) {
                    this.online();
                } else {
                    this.offline();
                }
                return jQuery(window).bind({
                    online: this._onOnline,
                    offline: this._onOffline
                });
            },
            Offline.prototype.annotations = function () {
                return this.cache
            },
            Offline.prototype.online = function () {
                return this.publish("online", [this]), this
            },
            Offline.prototype.offline = function () {
                return this.publish("offline", [this]), this
            },
            Offline.prototype.isOnline = function () {
                return window.navigator.onLine
            },
            Offline.prototype.loadAnnotationsFromStore = function () {
                var annotation, annotations, current, _i, _len;
                current = [];
                annotations = this.store.all(Offline.ANNOTATION_PREFIX);
                for (_i = 0, _len = annotations.length; _i < _len; _i++) {
                    annotation = annotations[_i];
                    if (this.options.shouldLoadAnnotation(annotation)) {
                        this.publish("beforeAnnotationLoaded", [annotation, this]);
                        this.publish("annotationLoaded", [annotation, this]);
                        this.cache[this.keyForAnnotation(annotation)] = annotation;
                        current.push(annotation);
                    }
                }
                if (current.length) {
                    this.annotator.loadAnnotations(current);
                }
                return this;
            },
            Offline.prototype.addAnnotation = function (annotation, options) {

                var isLoaded;
                if (options == null) {
                    options = {};
                }
                isLoaded = this.cache[this.options.getUniqueKey(annotation)];
                if (!isLoaded && this.options.shouldLoadAnnotation(annotation)) {
                    this.annotator.setupAnnotation(annotation, options.silent);
                } else {
                    this.updateStoredAnnotation(annotation);
                }
                return this;
            },
            Offline.prototype.removeAnnotation = function (annotation) {

                if (this.options.shouldLoadAnnotation(annotation)) {
                    this.annotator.deleteAnnotation(annotation);
                } else {
                    this.removeStoredAnnotation(annotation);
                }
                return this;
            },
            Offline.prototype.updateStoredAnnotation = function (annotation) {

                var id, key, local, storable;
                id = this.keyForAnnotation(annotation);
                key = this.keyForStore(annotation);
                local = this.cache[id];
                if (local) {
                    jQuery.extend(local, annotation);
                } else {
                    local = this.cache[id] = annotation;
                }
                storable = jQuery.extend({}, local);
                delete storable.highlights;
                this.store.set(key, storable);
                return this;
            },
            Offline.prototype.removeStoredAnnotation = function (annotation) {

                var id, key;
                id = this.keyForAnnotation(annotation);
                key = this.keyForStore(annotation);
                this.store.remove(key);
                delete this.cache[id];
                return this;
            },
            Offline.prototype.keyForAnnotation = function (annotation) {
                return this.options.getUniqueKey.call(this, annotation, this);
            },
            Offline.prototype.keyForStore = function (annotation) {
                return Offline.ANNOTATION_PREFIX + this.keyForAnnotation(annotation);
            },
            Offline.prototype._onOnline = function (event) {
                return this.online();
            },
            Offline.prototype._onOffline = function (event) {
                return this.offline()
            },
            Offline.prototype._onAnnotationCreated = function (annotation) {
                return this.updateStoredAnnotation(annotation);
            },
            Offline.prototype._onAnnotationUpdated = function (annotation) {
                return this.updateStoredAnnotation(annotation);
            },
            Offline.prototype._onAnnotationDeleted = function (annotation) {
                return this.removeStoredAnnotation(annotation);
            },
            Offline
    }(Annotator.Plugin),
        Annotator.Plugin.Offline.Store = b = function (a) {
            function Store() {
                Store.__super__.constructor.apply(this, arguments)
            }

            return e(Store, a), Store.KEY_PREFIX = "annotator.offline/", Store.CACHE_DELIMITER = "--cache--", Store.localStorage = window.localStorage, Store.isSupported = function () {
                try {
                    return "localStorage"in window && window.localStorage !== null
                } catch (a) {
                    return !1
                }
            },
                Store.now = function () {
                    return (new Date).getTime()
                },
                Store.prototype.all = function (a) {
                    var c, d, e, f;
                    a == null && (a = ""), f = [], d = this.prefixed(a);
                    for (c in localStorage) {
                        if (c.indexOf(d) !== 0)continue;
                        e = this.get(c.slice(Store.KEY_PREFIX.length)), f.push(e)
                    }
                    return f
                },
                Store.prototype.get = function (a) {
                    var c;
                    return c = Store.localStorage.getItem(this.prefixed(a)), c && (c = this.checkCache(c), c || this.remove(a)), JSON.parse(c)
                },
                Store.prototype.set = function (a, c, d) {
                    c = JSON.stringify(c), d && (c = Store.now() + d + Store.CACHE_DELIMITER + c);
                    try {
                        Store.localStorage.setItem(this.prefixed(a), c)
                    } catch (e) {
                        this.publish("error", [e, this])
                    }
                    return this
                },
                Store.prototype.remove = function (a) {
                    return Store.localStorage.removeItem(this.prefixed(a)), this
                },
                Store.prototype.clear = function () {

                    var key, localStorage;
                    localStorage = Store.localStorage;
                    for (key in localStorage) {
                        if (key.indexOf(Store.KEY_PREFIX) === 0) {
                            localStorage.removeItem(key);
                        }
                    }
                    return this;
                },
                Store.prototype.prefixed = function (a) {
                    return Store.KEY_PREFIX + a
                },
                Store.prototype.checkCache = function (a) {
                    var c;
                    return a.indexOf(Store.CACHE_DELIMITER) > -1 && (c = a.split(Store.CACHE_DELIMITER), a = Store.now() > c.shift() ? null : c.join(Store.CACHE_DELIMITER)), a
                },
                Store
        }(Annotator.Delegator)
})).call(this);
